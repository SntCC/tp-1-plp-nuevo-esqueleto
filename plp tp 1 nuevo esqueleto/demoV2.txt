Demostración punto 12:

queremos demostrar que :

∀e:Expr.cantLit e = S (cant0p e)

para esto, basta probar P talque :

Sea P(t) = cantlit t = S (cant0p t)
para lo mismo, usamos inducción estructural en t:

1)-caso base const; P(const n)
2)-caso base rango; P(Rango x y)
3)-caso recursivo suma; P (suma E1 E2)

miramos los casos:

1)- caso base t = const x ; para todo x de tipo nat.

P(const x) =

cantLit(const x) = S (cant0p (const x))
cantLit(const x) = S Z {01}
S Z = S Z {L1}

con esto queda comprobado nuestro caso base const.

2)- caso base rango : para todo x y de tipo float vale que:

P(rango x y) =

cantLit (rango x y) = S cant0p (rango x y)
cantLit (rango x y) = S (Z){02}
S Z = S Z {L2}

con esto queda comprobado el caso base rango.

3)-caso recursivo suma

A continuación demostramos el caso suma; los casos resta, mult y div se omiten por ser análogos.

Al ser un caso recursivo, vamos a plantear una hipotesis y tesis para el mismo:

∀ ex1 ex2 ::Expr. P(ex1) && P (ex2) => P(suma ex1 ex2)

esto expandido sería:

HI1 = cantLit ex1 = S (cant0p ex1)
HI2 = cantlit ex2 = S (cant0p ex2)

y la tesis a probar sería :

P(suma ex1 ex2) = 

cantLit(suma ex1 ex2)   = S (cant0p (suma ex1 ex2)) 

cantLit(suma ex1 ex2) = S (S(suma (cant0p ex1) (cant0p ex2))) {03}

suma (cantLit ex1) (cantLit ex2) = S (S (suma (cant0p ex1) (cant0p ex2))) {L3}

suma (S cant0p ex1) (S cant0p ex2) = S (S (suma (cant0p ex1) (cant0p ex2))) {HI1 y HI2}

S (suma (cant0p ex1) (S cant0p ex2)) = S (S (suma (cant0p ex1) (cant0p ex2))) {S2}

S (suma (S cant0p ex2) (cant0p ex1)) = S (S (suma (cant0p ex1) (cant0p ex2))) {CONMUT}

S (S (suma (cant0p ex2) (cant0p ex1))) = S (S (suma (cant0p ex1) (cant0p ex2))) {S2}

S (S (suma (cant0p ex1) (cant0p ex2))) = S (S (suma (cant0p ex1) (cant0p ex2))) {CONMUT}

con esto queda demostrado nuestro caso recursivo, probando así que P se cumple para todos los casos, y por ende nuestra propiedad es verdadera.
